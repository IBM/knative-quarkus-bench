# dna-event Project

This is a project to port and test [serverless-benchmarks](https://github.com/spcl/serverless-benchmarks) using Quarkus
[Funqy Knative Events Binding](https://quarkus.io/guides/funqy-knative-events).
This is an OpenShift-ready version of
[504.dna-visualisation](https://github.com/spcl/serverless-benchmarks/tree/master/benchmarks/500.scientific/504.dna-visualisation).
Note that [Quarkus Funqy](https://quarkus.io/guides/funqy) extensions only support **knative eventing** if you deploy your services to OpenShift.
Funqy HTTP binding supports knative serving (only), but it only runs in local environment.

This project currently focus on graph-based benchmarks in `500.scientific` group, but it should be usable for other groups of the benchmark suite. 
We use [JFASTA](http://jfasta.sourceforge.net/example1.html) to read DNA sequence file in FASTA format, and then
compute Squiggle graph plots as a replacement of [Benjamin Lee's Squiggle library](https://github.com/Benjamin-Lee/squiggle), 
which is used in the original benchmark implementation.

If you want to learn more about Quarkus, please visit its website: https://quarkus.io/ .

## Packaging the JVM version of application

The application can be packaged using:
```shell script
$ ./mvnw clean package
```
It produces the `quarkus-run.jar` file in the `target/quarkus-app/` directory.

## Creating a native executable

You can create a native executable using: 
```shell script
./mvnw package -Pnative
```

Or, if you don't have GraalVM installed, you can run the native executable build in a container using: 
```shell script
./mvnw package -Pnative -Dquarkus.native.container-build=true
```

It produces the  native executable: `./target/dne-event-0.0.1-SNAPSHOT-runner`

If you want to learn more about building native executables, please consult https://quarkus.io/guides/maven-tooling.html.


## Creating docker images

You need to create a docker image to run your application as a knative function. 
Note that you need to push your image to a docker image repository that is accessible from your OpenShift services, such as
Docker Hub, JFrog Artifactory, or any repository your cloud provider supports.

You can use the `Dockerfile` generated by Quarkus maven plugin without modification.
The only thing that depends on your environment is the repository name to tag your docker image.

To build and push a jvm image:
```shell script
$ docker build -f src/main/docker/Dockerfile.jvm -t <repositoryName>/sebs-dnavis:jvm .
$ docker push <repositoryName>/sebs-dnavis:jvm
```

To build and push a native image:
```shell script
$ docker build -f src/main/docker/Dockerfile.native -t <repositoryName>/sebs-dnavis:native .
$ docker push <repositoryName>/sebs-dnavis:native
```

## Running the application

### Prerequisite
You need an access to OpenShift/Kubernetes environment with knative enabled. 
Then, setup CLI tools [`oc` (openshift client)](https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/stable/),
[`kn`](https://knative.dev/docs/install/client/install-kn/), and [`kubectl`](https://kubernetes.io/docs/tasks/tools/).
You also need to configure your openshift project/namespace to be able to pull your docker images.

### Knative eventing resouces
In knative eventing, you need to create three resources explicitly. Then, knative system creates depending resources automatically.
The three resouces are [`broker`](https://knative.dev/docs/eventing/broker/), `service`, 
and [`trigger`](https://knative.dev/docs/eventing/broker/triggers/).
Here is their brief description:
- `Broker` is an event queue, and only one broker is needed in a simple setup. You can create it manually with any name, or let the knative system
automatically create and manage a default broker named `default` by adding a label to the namespace.
- `Service` is the instance of your function. `Service` describes which docker image is used to create a pod and how the pod will be managed.
- `Trigger` subscribes the broker, filters events, and transfers them to subscribing services.

The knative system has [a feature to help creating and managing a broker](https://knative.dev/docs/eventing/sugar/#automatic-broker-creation).
Howeve, note that this broker is not suitable for production. It does not provide persistency of events becuase it uses in-memory channel.
It is only  for development.

### Depolying services
To deploy knative eventing service, you need to deploy the three resources in the order of `broker`, `service`, and `trigger`.  
Since it may take a while to deploy a resource, it is better to confirm that the deployment finishes before deploying the next one.

#### Step 1. Deplying the broker:
```shell script
$ oc apply -f src/main/roks/broker.yaml 
broker.eventing.knative.dev/default created
$ oc get broker
NAME      URL                                                                                 AGE   READY   REASON
default   http://broker-ingress.knative-eventing.svc.cluster.local/sebs-funqy-event/default   9s    True    
```

#### Step 2. Deploying the jvm version of the service:
```shell script
$ oc apply -f sebs-dnavis-jvm.yaml 
service.serving.knative.dev/sebs-dnavis created
$ oc get ksvc
NAME                                        URL                                                                                                                     LATESTCREATED       LATESTREADY         READY   REASON
service.serving.knative.dev/sebs-dnavis   https://sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud   sebs-dnavis-jvm   sebs-dnavis-jvm   True    
```
This command creates a knative service named `sebs-dnavis` and its revision `sebs-dnavis-jvm`.

If the service does not become ready even after a while, check the status of the revision:
```shell script
$ oc get ksvc
NAME                                        URL                                                                                                                     LATESTCREATED       LATESTREADY   READY     REASON
service.serving.knative.dev/sebs-dnavis   https://sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud   sebs-dnavis-jvm                 Unknown   RevisionMissing
$ oc get revisions
NAME                                             CONFIG NAME     K8S SERVICE NAME    GENERATION   READY   REASON   ACTUAL REPLICAS   DESIRED REPLICAS
revision.serving.knative.dev/sebs-dnavis-jvm   sebs-dnavis   sebs-dnavis-jvm   1            True             1                 1
```
If revision is ready, the service will be ready soon.
Otherwise, you need to investigate the reason from the ouput of `oc describe revisions` and/or other commands.

#### Step 3. Deploying the native version of the service:
A service can have multiple revisions to manage history of a service during its life cycle. Adding a new service to an existing service
is considerted to create a new revision. So, we can conbine jvm and native versions as a single service using this mechanism.
```shell script
$ oc apply -f sebs-dnavis-native.yaml 
service.serving.knative.dev/sebs-dnavis configured
$ oc get ksvc
NAME                                        URL                                                                                                                     LATESTCREATED          LATESTREADY            READY   REASON
service.serving.knative.dev/sebs-dnavis   https://sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud   sebs-dnavis-native   sebs-dnavis-native   True
$ oc get revisions
NAME                                                CONFIG NAME     K8S SERVICE NAME       GENERATION   READY   REASON   ACTUAL REPLICAS   DESIRED REPLICAS
revision.serving.knative.dev/sebs-dnavis-jvm      sebs-dnavis   sebs-dnavis-jvm      1            True             0                 0
revision.serving.knative.dev/sebs-dnavis-native   sebs-dnavis   sebs-dnavis-native   2            True             1                 1
```

#### Step 4. Deploy the trigger:
```shell script
$ oc apply -f sebs-dnavis-trigger.yaml 
trigger.eventing.knative.dev/sebs-dnavis created
$ oc get trigger 
NAME                                         BROKER    SUBSCRIBER_URI                                      AGE   READY   REASON
trigger.eventing.knative.dev/sebs-dnavis   default   http://sebs-dnavis.funqy-dual.svc.cluster.local   7s    True     
```

#### Step 5. Adjust traffic splitting between jvm and native version:
When a new revision is created, the knative system starts sending all requests to the new revision by default, 
as the new version is considered to be the latest one.
You can check the splitting ratio by using `kn` command:
```shell script
$ kn revisions list 
NAME                   SERVICE         TRAFFIC   TAGS   GENERATION   AGE   CONDITIONS   READY   REASON
sebs-dnavis-native   sebs-dnavis   100%             2            32s   4 OK / 4     True    
sebs-dnavis-jvm      sebs-dnavis                    1            14m   3 OK / 4     True    
```

This ratio can be changed by specifying `.spec.traffic.[ { revisionName: <name1>, percent <ratio1> }, ... ]` in 
the Service definition yaml, or change dynamically by using `kn` command:
```shell script
$ kn service update sebs-dnavis --traffic sebs-dnavis-jvm=50 --traffic sebs-dnavis-native=50
Updating Service 'sebs-dnavis' in namespace 'funqy-dual':

  0.080s The Route is still working to reflect the latest desired specification.
  0.149s Ingress has not yet been reconciled.
  0.224s Waiting for load balancer to be ready
  0.405s Ready to serve.

Service 'sebs-dnavis' with latest revision 'sebs-dnavis-native' (unchanged) is available at URL:
https://sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud
$ kn revisions list 
NAME                   SERVICE         TRAFFIC   TAGS   GENERATION   AGE    CONDITIONS   READY   REASON
sebs-dnavis-native   sebs-dnavis   50%              2            100s   3 OK / 4     True    
sebs-dnavis-jvm      sebs-dnavis   50%              1            15m    3 OK / 4     True    
```
For more detail, check the knative [document](https://knative.dev/docs/serving/traffic-management/).

Now your service should be ready. You can check the status of all the resources with `oc get all`.
A sample output is shown in the Appendix section at the end of this document.


### Invocking the function (via external endpoint)
Knative eventing services receives cloud events. The cloud event is actually an HTTP POST request 
with some [required headers](https://github.com/cloudevents/spec/blob/v1.0/spec.md#required-attributes).
You can use `curl` command to send a cloud event to invoke your function.

#### Step 1. Find the endpoint URL from knative service:
```shell script
$ oc get ksvc
NAME            URL                                                                                                                     LATESTCREATED          LATESTREADY            READY   REASON
sebs-dnavis   https://sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud   sebs-dnavis-native   sebs-dnavis-native   True    
```
The URL field shows the endpoint.

#### Step 2. Send cloud events:
You need to specify four required headers (`ce-type`, `ce-id`, `ce-specversion`, and `ce-source`) of the cloud event and post data (`-d '<json-map>'`).
Note that the example below uses a dummy map (`{ "key":"value" }`) to use the default value without error:
```
$ curl -v -X POST -d '{ "key":"value" }' -H 'ce-type: dnavis' -H 'ce-id: 1' -H 'ce-specversion: 1.0' -H 'ce-source: curl' -H 'Content-Type: application/json' https://sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud
...
> POST / HTTP/1.1
> Host: sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud
> User-Agent: curl/7.61.1
> Accept: */*
> ce-type: bfs
> ce-id: 1
> ce-specversion: 1.0
> ce-source: curl
> Content-Type: application/json
> Content-Length: 6
> 
...
< HTTP/1.1 200 OK
< ce-id: 2d99bea6-7959-4140-a50b-489790cfdaae
< ce-source: bfs
< ce-specversion: 1.0
< ce-type: bfs.output
< content-length: 173
< content-type: application/json
< date: Sun, 19 Dec 2021 21:37:10 GMT
< x-envoy-upstream-service-time: 2540
< server: envoy
< Set-Cookie: 5afd088a0e8a11cb677a8ab3853c2292=8c8e7ef1cd95bc3d4d8efa3e16e8e81b; path=/; HttpOnly
< 
* Connection #0 to host sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud left intact
{"result":{"bucket":"trl-knative-benchmark-bucket","key":"504/out/bacillus_subtilis_squiggle.json"},"measurement":{"serialize_time":3.709514741,"download_time":7.916511755,"upnload_time":5.44E-7,"compute_time":0.0583106}}
```

The cloud evnet attribute `type` (specified as `-H 'cd-type: dnavis`) specifies the function name to be invoked.
If the service contains more than one function, you can select the function to invoke by using this HTTP header.

You can add [optional attributes](https://github.com/cloudevents/spec/blob/v1.0/spec.md#optional-attributes) and/or 
your own header as [extension context attributes](https://github.com/cloudevents/spec/blob/v1.0/spec.md#extension-context-attributes)
to help filtering events. 
In such case, you also need to add filter configuration in the target yaml file as `{.spec.filter.attributes.<EventAttr>: <ExpectedValue>}`.

The post data specified with `-d` option is the parameter for the function. 
Since our example receives only one string parameter that specifies the test data size, just sending a string is sufficient.

Be careful about quartation marks. In Funqy, post data need to be JSON format. So, a string value in post data needs to have double quatation marks (`"`)
aroud the data. You may also need another quartation marks or back-quote (`\`) to avoid shell command line interpretation.

After invocation of the service, you can confirm that a pod is created and running:
```shell script
$ oc get pods
NAME                                           READY   STATUS    RESTARTS   AGE
sebs-dnavis-jvm-deployment-545ccdb84-j2lx8   2/2     Running   0          6s
```
In this case, the request happened to be delivered to the jvm version. If you send more requests, some request will also be delivered to 
the native version and pods for both jvm version and native version start running:
```shell script
$ oc get pods
NAME                                               READY   STATUS    RESTARTS   AGE
curler                                             1/1     Running   0          3d11h
sebs-dnavis-jvm-deployment-545ccdb84-j2lx8       2/2     Running   0          15s
sebs-dnavis-native-deployment-5d4f56bbdb-hnnnv   2/2     Running   0          6s
```

### Invocking the function (via internal endpoint)
For performance measurement, it is preferable to use internal endpoint to send requests because we can avoid disturbance from other users,
as well as we can avoid disturbing other users.

#### Step 1. Deplying curler pod (once per project):
We need a pod to run curl command in our cluster. You can use 
[a yaml filein our knative-serverless-benchmark project](https://github.ibm.com/trl-quarkus/knative-serverless-benchmark/blob/master/src/main/k8s/curler.yaml). 
For more detail about the curler pod, 
check [knative eventing guide page](https://knative.dev/docs/eventing/getting-started/#creating-a-pod-as-an-event-producer).
```shell script
$ oc apply -f curler.yaml
$ oc get pods
NAME     READY   STATUS    RESTARTS   AGE
curler   1/1     Running   0          3d11h
```

#### Step 2. Find the internal endpoint URL from trigger:
There are several services/resources that have internal endpoints. For our testing with traffic spliting, the endpoint of `trigger` is
useful because the `curl` command works synchronously, so we can receive HTTP response code and reply from the service.
When a request triggers starting a new pod, the `curl` command wait for launching the new pod and handling the request.
```shell script
$ oc get triggers
NAME            BROKER    SUBSCRIBER_URI                                      AGE   READY   REASON
sebs-dnavis   default   http://sebs-dnavis.funqy-dual.svc.cluster.local   48m   True    
```

Note: You can also use the endpoint of the `broker`, but this endpoint works asynchronously. The `curl` command just returns
`202 Accepted` response code after posting a cloud event to the broker, and no reply from the service is shown in the terminal.
You need to add a subscriber to the response if you want to verify the response. Although this is the actual way of handling
eventing requests, it is inconvenient for perfromance measurement.

#### Step 3. Send cloud events via the internal endpoint:
You can run the `curl` command in the `curler` pod by using `kubectl` command:
```shell script
$ kubectl exec curler -- curl -v -X POST -d '"test"' -H 'ce-type: dnavis' -H 'ce-id: 1' -H 'ce-specversion: 1.0' -H 'ce-source: curl' -H 'Content-Type: application/json' http://sebs-dnavis.funqy-dual.svc.cluster.local
...
> POST / HTTP/1.1
> Host: sebs-dnavis.funqy-dual.svc.cluster.local
> User-Agent: curl/7.71.1
> Accept: */*
> ce-type: dnavis
> ce-id: 1
> ce-specversion: 1.0
> ce-source: curl
> Content-Type: application/json
> Content-Length: 6
> 
} [6 bytes data]
* upload completely sent off: 6 out of 6 bytes
100     6    0     0  100     6      0      4  0:00:01  0:00:01 --:--:--     4* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< ce-id: e3795fca-46bb-4a6f-bd21-b3349e946ab4
< ce-source: dnavis
< ce-specversion: 1.0
< ce-type: dnavis.output
< content-length: 167
< content-type: application/json
< date: Sun, 19 Dec 2021 20:22:08 GMT
< x-envoy-upstream-service-time: 1920
< server: envoy
< 
{ [167 bytes data]
100   173  100   167  100     6     86      3  0:00:02  0:00:01  0:00:{"result":{"bucket":"trl-knative-benchmark-bucket","key":"504/out/bacillus_subtilis_squiggle.json"},"measurement":{"serialize_time":3.709514741,"download_time":7.916511755,"upnload_time":5.44E-7,"compute_time":0.0583106}}01    89
* Connection #0 to host sebs-dnavis.funqy-dual.svc.cluster.local left intact
```

Note that the commands after `--` is the command to be executed in the pod. 
You login to the pod by using `kubectl exec -i -t curler -- /bin/bash` if you want.
(Need `-i` and `-t` options to connect stdin/stdout to the terminal)

## Stopping the application
To stop the application, delete the resources in the opposite order you created them, that is, `trigger`, `service`, and `broker`.
It is recommended to delete the broker if you use the default MT in-memory broker because this broker may not be fully cleaned up
when a subsclibing trigger is deleted. For other brokers, you can keep using it to deploy another application.
```shell script
$ oc delete -f sebs-dnavis-trigger.yaml 
trigger.eventing.knative.dev "sebs-dnavis" deleted
$ oc delete -f sebs-dnavis-jvm.yaml
service.serving.knative.dev "sebs-dnavis" deleted
$ oc get ksvc
No resources found in funqy-dual namespace.
$ oc get revisions
No resources found in funqy-dual namespace.
$ oc delete -f broker.yaml 
broker.eventing.knative.dev "default" deleted
$ oc get all
NAME         READY   STATUS    RESTARTS   AGE
pod/curler   1/1     Running   0          3d13h
```

Note: All revisions are deleted when a service is deleted. 
So only the yaml file for the jvm version is used for deletion in this example.


## Appendix: All resources after deploying the both jvm and native versions of the service
```shell script
$ oc get all
NAME         READY   STATUS    RESTARTS   AGE
pod/curler   1/1     Running   0          3d12h

NAME                                     TYPE           CLUSTER-IP       EXTERNAL-IP                                                  PORT(S)                                      AGE
service/default-kne-trigger-kn-channel   ExternalName   <none>           imc-dispatcher.knative-eventing.svc.cluster.local            <none>                                       125m
service/sebs-dnavis                    ExternalName   <none>           kourier-internal.knative-serving-ingress.svc.cluster.local   80/TCP                                       124m
service/sebs-dnavis-jvm                ClusterIP      172.21.38.122    <none>                                                       80/TCP                                       124m
service/sebs-dnavis-jvm-private        ClusterIP      172.21.90.152    <none>                                                       80/TCP,9090/TCP,9091/TCP,8022/TCP,8012/TCP   124m
service/sebs-dnavis-native             ClusterIP      172.21.39.30     <none>                                                       80/TCP                                       110m
service/sebs-dnavis-native-private     ClusterIP      172.21.170.117   <none>                                                       80/TCP,9090/TCP,9091/TCP,8022/TCP,8012/TCP   110m

NAME                                              READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/sebs-dnavis-jvm-deployment      0/0     0            0           124m
deployment.apps/sebs-dnavis-native-deployment   0/0     0            0           110m

NAME                                                         DESIRED   CURRENT   READY   AGE
replicaset.apps/sebs-dnavis-jvm-deployment-545ccdb84       0         0         0       124m
replicaset.apps/sebs-dnavis-native-deployment-5d4f56bbdb   0         0         0       110m

NAME                                         BROKER    SUBSCRIBER_URI                                      AGE    READY   REASON
trigger.eventing.knative.dev/sebs-dnavis   default   http://sebs-dnavis.funqy-dual.svc.cluster.local   122m   True    

NAME                                  URL                                                                           AGE    READY   REASON
broker.eventing.knative.dev/default   http://broker-ingress.knative-eventing.svc.cluster.local/funqy-dual/default   125m   True    

NAME                                                        URL                                                                  AGE    READY   REASON
inmemorychannel.messaging.knative.dev/default-kne-trigger   http://default-kne-trigger-kn-channel.funqy-dual.svc.cluster.local   125m   True    

NAME                                                                                            AGE    READY   REASON
subscription.messaging.knative.dev/default-sebs-dnavis-06b2fac4-07ec-4726-8303-85ed859ad72f   122m   True    

NAME                                      URL                                                                                                                     READY   REASON
route.serving.knative.dev/sebs-dnavis   https://sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud   True    

NAME                                        URL                                                                                                                     LATESTCREATED          LATESTREADY            READY   REASON
service.serving.knative.dev/sebs-dnavis   https://sebs-dnavis-funqy-dual.trl-osk-roks-b8ef7649236a07f2b2866d2585e12cb2-0000.jp-osa.containers.appdomain.cloud   sebs-dnavis-native   sebs-dnavis-native   True    

NAME                                              LATESTCREATED          LATESTREADY            READY   REASON
configuration.serving.knative.dev/sebs-dnavis   sebs-dnavis-native   sebs-dnavis-native   True    

NAME                                                CONFIG NAME     K8S SERVICE NAME       GENERATION   READY   REASON   ACTUAL REPLICAS   DESIRED REPLICAS
revision.serving.knative.dev/sebs-dnavis-jvm      sebs-dnavis   sebs-dnavis-jvm      1            True             0                 0
revision.serving.knative.dev/sebs-dnavis-native   sebs-dnavis   sebs-dnavis-native   2            True             0                 0
```
